# setwd('~/crime.modeling/')
# source('Rscripts/helper_functions/ADAM.R')
# source('Rscripts/helper_functions/GPRCPP functions - 20200507.R')
print("Done uploading CPP functions.")
resuming.computation <- class(try(load(output.file.name), silent = T))
covariance.calls <- list(
K.mm = lapply(list(
"rcpp_k_se_diff(X.time.m.diff.sq, par.svi[1], par.svi[2], T)",
"rcpp_k_se_diff(X.time.m.diff.sq, par.svi[3], par.svi[4], T)",
"rcpp_k_per_diff(X.time.m.diff.2norm, par.svi[5], par.svi[6], 52, T)",
"rcpp_k_se_diff(X.geo.m.diff.sq, par.svi[7], par.svi[8], T)",
"diag(jitter.v, m.size)"
), function(i) parse(text = i)),
K.mn = lapply(list(
"rcpp_k_se(X.time.m, X.time.n, par.svi[1], par.svi[2], F)",
"rcpp_k_se(X.time.m, X.time.n, par.svi[3], par.svi[4], F)",
"rcpp_k_per(X.time.m, X.time.n, par.svi[5], par.svi[6], 52, F)",
"rcpp_k_se(X.geo.m, X.geo.n, par.svi[7], par.svi[8], F)"
), function(i) parse(text = i)),
K.nn = lapply(list(
"rcpp_k_se(X.time.n, X.time.n, par.svi[1], par.svi[2], T)",
"rcpp_k_se(X.time.n, X.time.n, par.svi[3], par.svi[4], T)",
"rcpp_k_per(X.time.n, X.time.n, par.svi[5], par.svi[6], 52, T)",
"rcpp_k_se(X.geo.n, X.geo.n, par.svi[7], par.svi[8], T)"
), function(i) parse(text = i))
)
jitter.v = 1
derivative.calls <- lapply(list(
'rcpp_step_k_se_svi(X.time.m, X.time.n,  par.svi[1], par.svi[2], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 1)',
'rcpp_step_k_se_svi(X.time.m, X.time.n,  par.svi[1], par.svi[2], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 2)',
'rcpp_step_k_se_svi(X.time.m, X.time.n,  par.svi[3], par.svi[4], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 1)',
'rcpp_step_k_se_svi(X.time.m, X.time.n,  par.svi[3], par.svi[4], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 2)',
'rcpp_step_k_per_svi(X.time.m, X.time.n, par.svi[5], par.svi[6], tail(par.svi, 1), 52, inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 1)',
'rcpp_step_k_per_svi(X.time.m, X.time.n, par.svi[5], par.svi[6], tail(par.svi, 1), 52, inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 2)',
'rcpp_step_k_se_svi(X.geo.m, X.geo.n,    par.svi[7], par.svi[8], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 1)',
'rcpp_step_k_se_svi(X.geo.m, X.geo.n,    par.svi[7], par.svi[8], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 2)',
'rcpp_step_sigma_sq_svi(tail(par.svi, 1), as.matrix(y.svi), as.matrix(m.svi), S.svi, Lambda, K.mn, inv.K.mm, K.tilde, batch.size)'
), function(i) parse(text = i))
print("Calls loaded.")
load(file = '~/Dropbox (INSEAD)/Crime Modeling/Resources/crime.data.week.to.use.Rdata')
# create pseudo-inputs
X.time.m <- as.matrix(centroids$centers[, 'week'])
X.geo.m <- as.matrix(centroids$centers[, c('lng.std', 'lat.std')])
m.size <- nrow(centroids$centers)
X.time.m.diff.sq <- rcpp_diff_sq_mx(X.time.m, X.time.m, T)
X.time.m.diff.2norm <- rcpp_diff_2norm_mx(X.time.m, X.time.m, T)
X.geo.m.diff.sq <- rcpp_diff_sq_mx(X.geo.m, X.geo.m, T)
# create all data
batch.size <- 5e3
X.sample <- as.matrix(select(st_drop_geometry(crime.data.week.to.use), week, lng.std, lat.std))
y.sample <- c(as.matrix(select(st_drop_geometry(crime.data.week.to.use), count)))
sample.size <- length(y.sample)
n.batches <- ncol(matrix(seq(sample.size), nrow = batch.size))
sample.size
# create all data
batch.size <- 1e4
X.sample <- as.matrix(select(st_drop_geometry(crime.data.week.to.use), week, lng.std, lat.std))
y.sample <- c(as.matrix(select(st_drop_geometry(crime.data.week.to.use), count)))
sample.size <- length(y.sample)
n.batches <- ncol(matrix(seq(sample.size), nrow = batch.size))
print(paste0("Batches are ", n.batches))
nrow(crime.data.ind.to.use)
nrow(crime.data.week.to.use)
nrow(crime.data.week.to.use) %% batch.size
nrow(crime.data.week.to.use) %% 1e5
sample.size <- nrow(crime.data.week.to.use) - test.size
test.size <- nrow(crime.data.week.to.use) %% 1e5
sample.size <- nrow(crime.data.week.to.use) - test.size
set.seed(1)
test.positions <- sample(seq(nrow(crime.data.week.to.use)), test.size)
test.positions
test.positions <- sample(seq(nrow(crime.data.week.to.use)), test.size)
test.positions
set.seed(1)
test.positions <- sample(seq(nrow(crime.data.week.to.use)), test.size)
test.positions
sample.size <- nrow(crime.data.week.to.use) - test.size
crime.data.week.to.use[-test.positions, ]
1 %in% test.positions
# create all test and sample data
batch.size <- 1e4
test.size <- nrow(crime.data.week.to.use) %% 1e5
set.seed(1)
test.positions <- sample(seq(nrow(crime.data.week.to.use)), test.size)
sample.size <- nrow(crime.data.week.to.use) - test.size
test.df <- crime.data.week.to.use[test.positions, ]
sample.df <- crime.data.week.to.use[-test.positions, ]
sort(sample(seq(nrow(crime.data.week.to.use)), test.size))
set.seed(1)
test.positions <- sort(sample(seq(nrow(crime.data.week.to.use)), test.size))
test.positions
sample.size <- nrow(crime.data.week.to.use) - test.size
test.df <- crime.data.week.to.use[test.positions, ]
sample.df <- crime.data.week.to.use[-test.positions, ]
dim(test.df)
dim(sample.df)
X.sample <- as.matrix(select(st_drop_geometry(sample.df), week, lng.std, lat.std))
y.sample <- c(as.matrix(select(st_drop_geometry(sample.df), count)))
n.batches <- ncol(matrix(seq(sample.size), nrow = batch.size))
print(paste0("Batches are ", n.batches))
# fit parameters
threshold <- 1e-4
step.size.var.par <- c(1e-3, 1e-2, 1e-2)
step.size.par <- c(1e-4, 1e-2, 1e-3)
learning.decay <- c(1, 1, .8)
resuming.computation == "try-error"
lapply(results, '[[', 2)[[order(sapply(lapply(results, '[[', 3), tail, 1), decreasing = T)[8]]]
lapply(results, '[[', 2)[[order(sapply(lapply(results, '[[', 3), tail, 1), decreasing = T)]]
lapply(results, '[[', 2)
[[order(sapply(lapply(results, '[[', 3), tail, 1), decreasing = T)]]
order(sapply(lapply(results, '[[', 3), tail, 1), decreasing = T)
lapply(results, '[[', 2)[order(sapply(lapply(results, '[[', 3), tail, 1), decreasing = T)]
lapply(results, '[[', 2)[order(sapply(lapply(results, '[[', 3), tail, 1), decreasing = T)]
lapply(results, '[[', 2)[order(sapply(lapply(results, '[[', 3), tail, 1), decreasing = T)[1:10]]
lapply(results, '[[', 2)[order(sapply(lapply(results, '[[', 3), tail, 1), decreasing = T)[1:20]]
do.call(rbind, lapply(results, '[[', 2)[order(sapply(lapply(results, '[[', 3), tail, 1), decreasing = T)[1:20]])
abs(do.call(rbind, lapply(results, '[[', 2)[order(sapply(lapply(results, '[[', 3), tail, 1), decreasing = T)[1:20]]))
abs(lapply(results, '[[', 2)[order(sapply(lapply(results, '[[', 3), tail, 1), decreasing = T)[1:20]])
lapply(results, '[[', 2)[order(sapply(lapply(results, '[[', 3), tail, 1), decreasing = T)[1:20]]
abs(do.call(rbind, lapply(results, '[[', 2)[order(sapply(lapply(results, '[[', 3), tail, 1), decreasing = T)[1:20]]))
geo.hot.start <- abs(do.call(rbind, lapply(results, '[[', 2)[order(sapply(lapply(results, '[[', 3), tail, 1), decreasing = T)[1:20]]))
geo.hot.start
save(geo.hot.start,
file = "/Volumes/nbertani/crime.modeling/data/geo.hot.start.Rdata"
)
load(file = '~/Dropbox (INSEAD)/Crime Modeling/Initialization study/fit.results_SET+SET+PERT.Rdata')
load(file = '/Volumes/nbertani/crime.modeling/data/geo.hot.starts.Rdata')
load(file = '/Volumes/nbertani/crime.modeling/data/geo.hot.start.Rdata')
fit.results[[1]]
fit.results[[2]]
# hot start parameters
fit.results.clean <- list()
for(i in seq(length(fit.results))) {
if(!is.null(fit.results[[i]]))
fit.results.clean <- append(fit.results.clean,  fit.results[i])
}
evidence <- sapply(fit.results.clean, '[[', 1)
evidence
fit.order <- order(evidence, decreasing = T)
fit.order
fit.pars <- lapply(fit.results.clean, '[[', 3)
fit.pars
lapply(fit.results.clean, '[[', 3)
lapply(fit.results.clean, '[[', 3)[fit.order[1:20]]
time.hot.start <-  do.call(rbind, lapply(fit.results.clean, '[[', 3)[fit.order[1:20]])
time.hot.start
sample(1:20, 1)
which.geo <- sample(1:20, 1)
which.geo
time.hot.start
-ncol(time.hot.start)
c(time.hot.start[which.time, -ncol(time.hot.start)])
which.time <- sample(1:20, 1)
which.geo <- sample(1:20, 1)
start.jitter <- 0
c(time.hot.start[which.time, -ncol(time.hot.start)])
max(time.hot.start[which.time, ncol(time.hot.start)], geo.hot.start[which.geo, ncol(geo.hot.start)])
c(time.hot.start[which.time, -ncol(time.hot.start)],
geo.hot.start[which.geo, -ncol(geo.hot.start)],
time.hot.start[which.time, ncol(time.hot.start)] + geo.hot.start[which.geo, ncol(geo.hot.start)]
)
length(derivative.calls) != length(initial.par.svi)
initial.par.svi <- c(time.hot.start[which.time, -ncol(time.hot.start)],
geo.hot.start[which.geo, -ncol(geo.hot.start)],
time.hot.start[which.time, ncol(time.hot.start)] + geo.hot.start[which.geo, ncol(geo.hot.start)]
)
length(derivative.calls) != length(initial.par.svi)
sample(c(-1, 1), length(initial.par.svi))
sample(c(-1, 1), length(initial.par.svi), replace = T)
sample(c(-1, 1), length(initial.par.svi), replace = T) * runif(length(initial.par.svi))
sample(c(-1, 1), length(initial.par.svi), replace = T) * runif(length(initial.par.svi)) * start.jitter
initial.par.svi * sample(c(-1, 1), length(initial.par.svi), replace = T) * runif(length(initial.par.svi)) * start.jitter
initial.par.svi <- initial.par.svi + initial.par.svi * sample(c(-1, 1), length(initial.par.svi), replace = T) * runif(length(initial.par.svi)) * start.jitter
par.svi <- initial.par.svi
par.svi.seq <- list()
print(c("Initial parameters are: ", round(initial.par.svi, 3)))
# Setup -------------------------------------------------------------------
start.time <- Sys.time()
print(start.time)
file.name <- paste0('20200601-fit_SET_SET_PERT_SEG_SEG_', random.start.indicator)
print(paste(file.name, 'Started.', sep = ' - '))
output.file.name <- paste0(
"~/crime.modeling/fit.progress/",
file.name,'.Rdata')
print(output.file.name)
if(!require(sf)) install.packages('sf'); library(sf)
if(!require(tidyverse)) install.packages('tidyverse'); library(tidyverse)
if(!require(parallel)) install.packages('parallel'); library(parallel)
random.start.indicator <- 1
setwd('~/Dropbox (INSEAD)/Crime Modeling/')
source('ADAM.R')
source('CPP code/GPRCPP functions - 20200507.R')
# setwd('~/crime.modeling/')
# source('Rscripts/helper_functions/ADAM.R')
# source('Rscripts/helper_functions/GPRCPP functions - 20200507.R')
print("Done uploading CPP functions.")
resuming.computation <- class(try(load(output.file.name), silent = T))
# Calls -------------------------------------------------------------------
covariance.calls <- list(
K.mm = lapply(list(
"rcpp_k_se_diff(X.time.m.diff.sq, par.svi[1], par.svi[2], T)",
"rcpp_k_se_diff(X.time.m.diff.sq, par.svi[3], par.svi[4], T)",
"rcpp_k_per_diff(X.time.m.diff.2norm, par.svi[5], par.svi[6], 52, T)",
"rcpp_k_se_diff(X.geo.m.diff.sq, par.svi[7], par.svi[8], T)",
"rcpp_k_se_diff(X.geo.m.diff.sq, par.svi[9], par.svi[10], T)",
"diag(jitter.v, m.size)"
), function(i) parse(text = i)),
K.mn = lapply(list(
"rcpp_k_se(X.time.m, X.time.n, par.svi[1], par.svi[2], F)",
"rcpp_k_se(X.time.m, X.time.n, par.svi[3], par.svi[4], F)",
"rcpp_k_per(X.time.m, X.time.n, par.svi[5], par.svi[6], 52, F)",
"rcpp_k_se(X.geo.m, X.geo.n, par.svi[7], par.svi[8], F)",
"rcpp_k_se(X.geo.m, X.geo.n, par.svi[9], par.svi[10], F)"
), function(i) parse(text = i)),
K.nn = lapply(list(
"rcpp_k_se(X.time.n, X.time.n, par.svi[1], par.svi[2], T)",
"rcpp_k_se(X.time.n, X.time.n, par.svi[3], par.svi[4], T)",
"rcpp_k_per(X.time.n, X.time.n, par.svi[5], par.svi[6], 52, T)",
"rcpp_k_se(X.geo.n, X.geo.n, par.svi[7], par.svi[8], T)",
"rcpp_k_se(X.geo.n, X.geo.n, par.svi[9], par.svi[10], T)"
), function(i) parse(text = i))
)
jitter.v = 1
derivative.calls <- lapply(list(
'rcpp_step_k_se_svi(X.time.m, X.time.n,  par.svi[1], par.svi[2], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 1)',
'rcpp_step_k_se_svi(X.time.m, X.time.n,  par.svi[1], par.svi[2], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 2)',
'rcpp_step_k_se_svi(X.time.m, X.time.n,  par.svi[3], par.svi[4], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 1)',
'rcpp_step_k_se_svi(X.time.m, X.time.n,  par.svi[3], par.svi[4], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 2)',
'rcpp_step_k_per_svi(X.time.m, X.time.n, par.svi[5], par.svi[6], tail(par.svi, 1), 52, inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 1)',
'rcpp_step_k_per_svi(X.time.m, X.time.n, par.svi[5], par.svi[6], tail(par.svi, 1), 52, inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 2)',
'rcpp_step_k_se_svi(X.geo.m, X.geo.n,    par.svi[7], par.svi[8], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 1)',
'rcpp_step_k_se_svi(X.geo.m, X.geo.n,    par.svi[7], par.svi[8], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 2)',
'rcpp_step_k_se_svi(X.geo.m, X.geo.n,    par.svi[9], par.svi[10], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 1)',
'rcpp_step_k_se_svi(X.geo.m, X.geo.n,    par.svi[9], par.svi[10], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 2)',
'rcpp_step_sigma_sq_svi(tail(par.svi, 1), as.matrix(y.svi), as.matrix(m.svi), S.svi, Lambda, K.mn, inv.K.mm, K.tilde, batch.size)'
), function(i) parse(text = i))
print("Calls loaded.")
# Prepare fit ---------------------------------------------------------------------
load(file = '~/Dropbox (INSEAD)/Crime Modeling/Resources/crime.data.week.to.use.Rdata')
# load(file = '~/crime.modeling/data/crime.data.week.to.use.Rdata')
# create pseudo-inputs
X.time.m <- as.matrix(centroids$centers[, 'week'])
X.geo.m <- as.matrix(centroids$centers[, c('lng.std', 'lat.std')])
m.size <- nrow(centroids$centers)
X.time.m.diff.sq <- rcpp_diff_sq_mx(X.time.m, X.time.m, T)
X.time.m.diff.2norm <- rcpp_diff_2norm_mx(X.time.m, X.time.m, T)
X.geo.m.diff.sq <- rcpp_diff_sq_mx(X.geo.m, X.geo.m, T)
# create all test and sample data
batch.size <- 1e4
test.size <- nrow(crime.data.week.to.use) %% 1e5
set.seed(1)
test.positions <- sort(sample(seq(nrow(crime.data.week.to.use)), test.size))
sample.size <- nrow(crime.data.week.to.use) - test.size
test.df <- crime.data.week.to.use[test.positions, ]
dim(test.df)
sample.df <- crime.data.week.to.use[-test.positions, ]
dim(sample.df)
X.sample <- as.matrix(select(st_drop_geometry(sample.df), week, lng.std, lat.std))
y.sample <- c(as.matrix(select(st_drop_geometry(sample.df), count)))
n.batches <- ncol(matrix(seq(sample.size), nrow = batch.size))
print(paste0("Batches are ", n.batches))
# fit parameters
threshold <- 1e-4
step.size.var.par <- c(1e-3, 1e-2, 1e-2)
step.size.par <- c(1e-4, 1e-2, 1e-3)
learning.decay <- c(1, 1, .8)
# load data from scratch data - first run of code only
if (resuming.computation == "try-error") {
print("This is the first run of this code.")
load(file = '~/Dropbox (INSEAD)/Crime Modeling/Initialization study/fit.results_SET+SET+PERT.Rdata')
load(file = '/Volumes/nbertani/crime.modeling/data/geo.hot.start.Rdata')
# load(file = '~/crime.modeling/data/fit.results_SET_SET_PERT.Rdata')
# load(file = '~/crime.modeling/data/geo.hot.start.Rdata')
# hot start parameters
fit.results.clean <- list()
for(i in seq(length(fit.results))) {
if(!is.null(fit.results[[i]]))
fit.results.clean <- append(fit.results.clean,  fit.results[i])
}
evidence <- sapply(fit.results.clean, '[[', 1)
fit.order <- order(evidence, decreasing = T)
time.hot.start <-  do.call(rbind, lapply(fit.results.clean, '[[', 3)[fit.order[1:20]])
which.time <- sample(1:20, 1)
which.geo <- sample(1:20, 1)
start.jitter <- 0
initial.par.svi <- c(time.hot.start[which.time, -ncol(time.hot.start)],
geo.hot.start[which.geo, -ncol(geo.hot.start)],
time.hot.start[which.time, ncol(time.hot.start)] + geo.hot.start[which.geo, ncol(geo.hot.start)]
)
if(length(derivative.calls) != length(initial.par.svi)) stop("number of parameter different from number of derivatives!!!")
initial.par.svi <- initial.par.svi + initial.par.svi * sample(c(-1, 1), length(initial.par.svi), replace = T) * runif(length(initial.par.svi)) * start.jitter
par.svi <- initial.par.svi
par.svi.seq <- list()
print(c("Initial parameters are: ", round(initial.par.svi, 3)))
# initial conditions
epoch <- 0
iteration <- 0
save.count <- 1
batch.lik.sequence <- -Inf
m.svi <- rep(0, m.size)
S.svi <- Reduce('+', mclapply(covariance.calls[['K.mm']], eval))
}
# check runtime
run.time <- difftime(Sys.time(), start.time, units = 'mins')
print(run.time)
repeat({
# check runtime
run.time <- difftime(Sys.time(), start.time, units = 'mins')
print(run.time)
# save every 5 hours
if (run.time > 300 * save.count) {
save(
initial.par.svi, par.svi, m.svi, S.svi, par.svi.seq,
epoch, iteration, batch.lik.sequence, positions.mx,
file = output.file.name,
safe = T
)
save.count <- save.count + 1
print(paste0('At ', round(run.time, 2), ', I have made save number ', save.count, '.'))
}
# update iteration
iteration <- iteration + 1
batch <- iteration %% n.batches
batch <- ifelse(batch == 0, n.batches, batch)
if (batch == 1) {
epoch <- epoch + 1
positions.mx <- matrix(sample(seq(sample.size)), nrow = batch.size)
print("Batches and positions updated.")
}
print(paste(c(epoch, iteration, batch, round(c(tail(batch.lik.sequence, 1), par.svi), 3)), collapse = " - "))
# draw minibatch
positions.batch.svi <- positions.mx[, batch]
y.svi <- y.sample[positions.batch.svi]
X.time.n <- as.matrix(X.sample[positions.batch.svi, 1])
X.geo.n <- as.matrix(X.sample[positions.batch.svi, 2:3])
# compute batch likelihood
batch.lik.sequence <- c(batch.lik.sequence, update.L3(covariance.calls, tail(par.svi, 1), jitter.v))
if (abs(diff(tail(batch.lik.sequence, 2))) < threshold) {
print("CONVEGENCE REACHED!!!")
break
}
# update variational parameters and hyperparameters
if (epoch < 3) {
var.par.svi <- update.variational.parameters(sigma.sq.svi = tail(par.svi, 1), step.size.var.par[1] * learning.decay[1] ^ (epoch - 1))
if (epoch == 2) {
par.svi <- par.svi + ADAM.step(derivative.calls, alpha = step.size.par[1] * learning.decay[1] ^ (epoch - 1))
}
}
if (epoch >= 3 && epoch < 10) {
var.par.svi <- update.variational.parameters(sigma.sq.svi = tail(par.svi, 1), step.size.var.par[2] * learning.decay[2] ^ (epoch - 1))
par.svi <- par.svi + ADAM.step(derivative.calls, alpha = step.size.par[2] * learning.decay[2] ^ (epoch - 1))
}
if (epoch >= 10) {
var.par.svi <- update.variational.parameters(sigma.sq.svi = tail(par.svi, 1), step.size.var.par[3] * learning.decay[3] ^ (epoch - 10))
par.svi <- par.svi + ADAM.step(derivative.calls, alpha = step.size.par[3] * learning.decay[3] ^ (epoch - 10))
}
# attribute new values to names
m.svi <- var.par.svi[[1]]
S.svi <- var.par.svi[[2]]
if((iteration %% 50) == 1) {
par.svi.seq[[(iteration - 1) %/% 50 + 1]] <- par.svi
}
})
batch.size <- 5e3
test.size <- nrow(crime.data.week.to.use) %% 1e5
set.seed(1)
test.positions <- sort(sample(seq(nrow(crime.data.week.to.use)), test.size))
sample.size <- nrow(crime.data.week.to.use) - test.size
test.df <- crime.data.week.to.use[test.positions, ]
dim(test.df)
sample.df <- crime.data.week.to.use[-test.positions, ]
dim(sample.df)
X.sample <- as.matrix(select(st_drop_geometry(sample.df), week, lng.std, lat.std))
y.sample <- c(as.matrix(select(st_drop_geometry(sample.df), count)))
n.batches <- ncol(matrix(seq(sample.size), nrow = batch.size))
print(paste0("Batches are ", n.batches))
# fit parameters
threshold <- 1e-4
step.size.var.par <- c(1e-3, 1e-2, 1e-2)
step.size.par <- c(1e-4, 1e-2, 1e-3)
learning.decay <- c(1, 1, .8)
# load data from scratch data - first run of code only
if (resuming.computation == "try-error") {
print("This is the first run of this code.")
load(file = '~/Dropbox (INSEAD)/Crime Modeling/Initialization study/fit.results_SET+SET+PERT.Rdata')
load(file = '/Volumes/nbertani/crime.modeling/data/geo.hot.start.Rdata')
# load(file = '~/crime.modeling/data/fit.results_SET_SET_PERT.Rdata')
# load(file = '~/crime.modeling/data/geo.hot.start.Rdata')
# hot start parameters
fit.results.clean <- list()
for(i in seq(length(fit.results))) {
if(!is.null(fit.results[[i]]))
fit.results.clean <- append(fit.results.clean,  fit.results[i])
}
evidence <- sapply(fit.results.clean, '[[', 1)
fit.order <- order(evidence, decreasing = T)
time.hot.start <-  do.call(rbind, lapply(fit.results.clean, '[[', 3)[fit.order[1:20]])
which.time <- sample(1:20, 1)
which.geo <- sample(1:20, 1)
start.jitter <- 0
initial.par.svi <- c(time.hot.start[which.time, -ncol(time.hot.start)],
geo.hot.start[which.geo, -ncol(geo.hot.start)],
time.hot.start[which.time, ncol(time.hot.start)] + geo.hot.start[which.geo, ncol(geo.hot.start)]
)
if(length(derivative.calls) != length(initial.par.svi)) stop("number of parameter different from number of derivatives!!!")
initial.par.svi <- initial.par.svi + initial.par.svi * sample(c(-1, 1), length(initial.par.svi), replace = T) * runif(length(initial.par.svi)) * start.jitter
par.svi <- initial.par.svi
par.svi.seq <- list()
print(c("Initial parameters are: ", round(initial.par.svi, 3)))
# initial conditions
epoch <- 0
iteration <- 0
save.count <- 1
batch.lik.sequence <- -Inf
m.svi <- rep(0, m.size)
S.svi <- Reduce('+', mclapply(covariance.calls[['K.mm']], eval))
}
# Run fit ------------------------------------------------------------------------
repeat({
# check runtime
run.time <- difftime(Sys.time(), start.time, units = 'mins')
print(run.time)
# save every 5 hours
if (run.time > 300 * save.count) {
save(
initial.par.svi, par.svi, m.svi, S.svi, par.svi.seq,
epoch, iteration, batch.lik.sequence, positions.mx,
file = output.file.name,
safe = T
)
save.count <- save.count + 1
print(paste0('At ', round(run.time, 2), ', I have made save number ', save.count, '.'))
}
# update iteration
iteration <- iteration + 1
batch <- iteration %% n.batches
batch <- ifelse(batch == 0, n.batches, batch)
if (batch == 1) {
epoch <- epoch + 1
positions.mx <- matrix(sample(seq(sample.size)), nrow = batch.size)
print("Batches and positions updated.")
}
print(paste(c(epoch, iteration, batch, round(c(tail(batch.lik.sequence, 1), par.svi), 3)), collapse = " - "))
# draw minibatch
positions.batch.svi <- positions.mx[, batch]
y.svi <- y.sample[positions.batch.svi]
X.time.n <- as.matrix(X.sample[positions.batch.svi, 1])
X.geo.n <- as.matrix(X.sample[positions.batch.svi, 2:3])
# compute batch likelihood
batch.lik.sequence <- c(batch.lik.sequence, update.L3(covariance.calls, tail(par.svi, 1), jitter.v))
if (abs(diff(tail(batch.lik.sequence, 2))) < threshold) {
print("CONVEGENCE REACHED!!!")
break
}
# update variational parameters and hyperparameters
if (epoch < 3) {
var.par.svi <- update.variational.parameters(sigma.sq.svi = tail(par.svi, 1), step.size.var.par[1] * learning.decay[1] ^ (epoch - 1))
if (epoch == 2) {
par.svi <- par.svi + ADAM.step(derivative.calls, alpha = step.size.par[1] * learning.decay[1] ^ (epoch - 1))
}
}
if (epoch >= 3 && epoch < 10) {
var.par.svi <- update.variational.parameters(sigma.sq.svi = tail(par.svi, 1), step.size.var.par[2] * learning.decay[2] ^ (epoch - 1))
par.svi <- par.svi + ADAM.step(derivative.calls, alpha = step.size.par[2] * learning.decay[2] ^ (epoch - 1))
}
if (epoch >= 10) {
var.par.svi <- update.variational.parameters(sigma.sq.svi = tail(par.svi, 1), step.size.var.par[3] * learning.decay[3] ^ (epoch - 10))
par.svi <- par.svi + ADAM.step(derivative.calls, alpha = step.size.par[3] * learning.decay[3] ^ (epoch - 10))
}
# attribute new values to names
m.svi <- var.par.svi[[1]]
S.svi <- var.par.svi[[2]]
if((iteration %% 50) == 1) {
par.svi.seq[[(iteration - 1) %/% 50 + 1]] <- par.svi
}
})
# Save --------------------------------------------------------------------
save(
initial.par.svi, par.svi, m.svi, S.svi, par.svi.seq,
epoch, iteration, batch.lik.sequence, positions.mx,
file = output.file.name,
safe = T
)
rbind(par.svi)
print(paste(file.name, 'Done.', sep = ' - '))
print(difftime(Sys.time(), start.time, units = 'mins'))
iteration
iteration > 10 && iteration < 50
iteration <= 10
iteration > 50
par.svi <- par.svi + ADAM.step(derivative.calls, alpha = step.size.par[1] * learning.decay[1] ^ (epoch - 1))
K.hat.star.svi.call <- lapply(list(
"rcpp_k_se(X.time.m, X.time.test, par.svi[1], par.svi[2], F)",
"rcpp_k_se(X.time.m, X.time.test, par.svi[3], par.svi[4], F)",
"rcpp_k_per(X.time.m, X.time.test, par.svi[5], par.svi[6], 52, F)",
"rcpp_k_se(X.geo.m, X.geo.test, par.svi[7], par.svi[8], F)",
"rcpp_k_se(X.geo.m, X.geo.test, par.svi[9], par.svi[10], F)"
), function(i) parse(text = i))
K.hat.star.svi
K.hat.star.svi <- Reduce('+', lapply(K.hat.star.svi.call, eval))
X.time.test <- as.matrix(select(st_drop_geometry(test.df), week))
X.geo.test <- as.matrix(select(st_drop_geometry(test.df), lng.std, lat.std))
K.mm <- Reduce('+', lapply(covariance.calls[['K.mm']], eval))
inv.K.mm <- chol2inv(chol(K.mm))
K.hat.star.svi <- Reduce('+', lapply(K.hat.star.svi.call, eval))
mu.star.svi <- t(K.hat.star.svi) %*% (inv.K.mm %*% m.svi)
mu.star.svi
y.test <- c(as.matrix(select(st_drop_geometry(test.df), count)))
mean((y.test - mu.star.svi) ^ 2)
sum((y.test - mu.star.svi) ^ 2)
sqrt(mean((y.test - mu.star.svi) ^ 2))
RMSE.seq <- c()
