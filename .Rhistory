load('crime_data_cc.Rdata')
load(file.choose())
table(crime.data.sf$week)
do.call(rbind,list(c(1,1), c(2,2)))
file.name
do.call(rbind,list(matrix(c(1,1,2,2),2,2), matrix(c(1,1,2,2),2,2)))
# Setup for Grid ----------------------------------------------------------
#!/usr/bin/env Rscript
# Setup -------------------------------------------------------------------
start.time <- Sys.time()
print(start.time)
file.name <- "fit.progress"
# output.file.name <- paste0(
#   "~/crime.modeling/fit.progress/",
#   file.name,'.Rdata')
output.file.name <- paste0(
"/Volumes/nbertani/crime.modeling/fit.progress/",
file.name,'.Rdata')
print(output.file.name)
print(paste(file.name, 'Started.', sep = ' - '))
# if(!require(sf)) install.packages('sf'); library(sf)
# if(!require(tidyverse)) install.packages('tidyverse'); library(tidyverse)
# if(!require(parallel)) install.packages('parallel'); library(parallel)
# Load results ------------------------------------------------------------
fit.results <- list()
for (random.start.indicator in 1:256) {
if(random.start.indicator == 1) pb <<- txtProgressBar(min = 0, max = 256, initial = 0, style = 3)
setTxtProgressBar(pb, random.start.indicator)
destination.file.name <- paste0(
"/Volumes/nbertani/crime.modeling/fit.progress/",
'short_', random.start.indicator, '.Rdata')
load(destination.file.name)
fit.results[[random.start.indicator]] <- list(
pars = par.svi,
L3.mean = mean(tail(batch.lik.sequence, 50))
)
}
fit.results[[1]]
which.min(sapply(fit.results, '[[', 2))
order(sapply(fit.results, '[[', 2))
fit.order <- order(sapply(fit.results, '[[', 2))
lapply(fit.results, '[[', 1)[[1]]
lapply(fit.results, '[[', 1)[[fit.order[1:10]]]
lapply(lapply(fit.results, '[[', 1), '[[' fit.order[1:10])
lapply(lapply(fit.results, '[[', 1), '[[', fit.order[1:10])
lapply(fit.results, '[[', 1)
lapply(fit.results, '[[', 1)[[c(1, 2)]]
fit.order[1:10]
list(fit.order[1:10])
lapply(lapply(fit.results, '[[', 1), '[[', fit.order[1:10])
lapply(fit.order[1:10], function(i) {lapply(fit.results, '[[', 1)[[i]]})
sapply(fit.order[1:10], function(i) {lapply(fit.results, '[[', 1)[[i]]})
sapply(fit.order[1:10], function(i) {lapply(fit.results, '[[', 2)[[i]]})
fit.order <- order(sapply(fit.results, '[[', 2), decreasing = T)
sapply(fit.order[1:10], function(i) {lapply(fit.results, '[[', 2)[[i]]})
sapply(fit.order[1:10], function(i) {lapply(fit.results, '[[', 1)[[i]]})
round(sapply(fit.order[1:10], function(i) {lapply(fit.results, '[[', 1)[[i]]}), 2)
source('/Volumes/nbertani/crime.modeling/Rscripts/fit-20200526-SETSEG-SET-PERTSEG-SEG-grid.R', echo=TRUE)
# Setup -------------------------------------------------------------------
start.time <- Sys.time()
print(start.time)
file.name <- paste0('20200526-fit_SETSEG_SET_PERTSEG_SEG_', random.start.indicator)
print(paste(file.name, 'Started.', sep = ' - '))
output.file.name <- paste0(
"~/crime.modeling/fit.progress/",
file.name,'.Rdata')
print(output.file.name)
if(!require(sf)) install.packages('sf'); library(sf)
if(!require(tidyverse)) install.packages('tidyverse'); library(tidyverse)
if(!require(parallel)) install.packages('parallel'); library(parallel)
random.start.indicator <- 1
setwd('~/Dropbox (INSEAD)/Crime Modeling/')
source('ADAM.R')
source('CPP code/GPRCPP functions - 20200507.R')
# setwd('~/crime.modeling/')
# source('Rscripts/helper_functions/ADAM.R')
# source('Rscripts/helper_functions/GPRCPP functions - 20200507.R')
print("Done uploading CPP functions.")
resuming.computation <- class(try(load(output.file.name), silent = T))
# Calls -------------------------------------------------------------------
covariance.calls <- list(
K.mm = lapply(list(
"rcpp_k_sese(     X.time.m, X.time.m, X.geo.m, X.geo.m,   par.svi[1], par.svi[2], par.svi[3], T)",
"rcpp_k_se_diff(  X.time.m.diff.sq,                       par.svi[4], par.svi[5], T)",
"rcpp_k_perse(    X.time.m, X.time.m, X.geo.m, X.geo.m,   par.svi[6], par.svi[7], par.svi[8], 52, T)",
"rcpp_k_se_diff(  X.geo.m.diff.sq,                        par.svi[9], par.svi[10], T)",
"diag(jitter.v, m.size)"
), function(i) parse(text = i)),
K.mn = lapply(list(
"rcpp_k_sese( X.time.m, X.time.n, X.geo.m, X.geo.n, par.svi[1], par.svi[2], par.svi[3], F)",
"rcpp_k_se(   X.time.m, X.time.n,                   par.svi[4], par.svi[5], F)",
"rcpp_k_perse(X.time.m, X.time.n, X.geo.m, X.geo.n, par.svi[6], par.svi[7], par.svi[8], 52,  F)",
"rcpp_k_se(   X.geo.m, X.geo.n,                     par.svi[9], par.svi[10], F)"
), function(i) parse(text = i)),
K.nn = lapply(list(
"rcpp_k_sese( X.time.n, X.time.n, X.geo.n, X.geo.n, par.svi[1], par.svi[2], par.svi[3], T)",
"rcpp_k_se(   X.time.n, X.time.n,                   par.svi[4], par.svi[5], T)",
"rcpp_k_perse(X.time.n, X.time.n, X.geo.n, X.geo.n, par.svi[6], par.svi[7], par.svi[8], 52, T)",
"rcpp_k_se(   X.geo.n, X.geo.n,                     par.svi[9], par.svi[10], T)"
), function(i) parse(text = i))
)
jitter.v = 1
derivative.calls <- lapply(list(
'rcpp_step_k_sese_svi(X.time.m, X.time.n, X.geo.m, X.geo.n,   par.svi[1], par.svi[2], par.svi[3], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 1)',
'rcpp_step_k_sese_svi(X.time.m, X.time.n, X.geo.m, X.geo.n,   par.svi[1], par.svi[2], par.svi[3], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 2)',
'rcpp_step_k_sese_svi(X.time.m, X.time.n, X.geo.m, X.geo.n,   par.svi[1], par.svi[2], par.svi[3], tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 3)',
'rcpp_step_k_se_svi(X.time.m, X.time.n,                       par.svi[4], par.svi[5],             tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 1)',
'rcpp_step_k_se_svi(X.time.m, X.time.n,                       par.svi[4], par.svi[5],             tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 2)',
'rcpp_step_k_perse_svi(X.time.m, X.time.n, X.geo.m, X.geo.n,  par.svi[6], par.svi[7], par.svi[8], tail(par.svi, 1), 52, inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 1)',
'rcpp_step_k_perse_svi(X.time.m, X.time.n, X.geo.m, X.geo.n,  par.svi[6], par.svi[7], par.svi[8], tail(par.svi, 1), 52, inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 2)',
'rcpp_step_k_perse_svi(X.time.m, X.time.n, X.geo.m, X.geo.n,  par.svi[6], par.svi[7], par.svi[8], tail(par.svi, 1), 52, inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 3)',
'rcpp_step_k_se_svi(X.geo.m, X.geo.n,                         par.svi[9], par.svi[10],            tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 1)',
'rcpp_step_k_se_svi(X.geo.m, X.geo.n,                         par.svi[9], par.svi[10],            tail(par.svi, 1), inv.K.mm, K.mn, as.matrix(y.svi), as.matrix(m.svi), S.svi, 2)',
'rcpp_step_sigma_sq_svi(tail(par.svi, 1), as.matrix(y.svi), as.matrix(m.svi), S.svi, Lambda, K.mn, inv.K.mm, K.tilde, batch.size)'
), function(i) parse(text = i))
print("Calls loaded.")
# Prepare fit ---------------------------------------------------------------------
load(file = '~/Dropbox (INSEAD)/Crime Modeling/Resources/crime.data.week.to.use.Rdata')
# load(file = '~/crime.modeling/data/crime.data.week.to.use.Rdata')
# create pseudo-inputs
X.time.m <- as.matrix(centroids$centers[, 'week'])
X.geo.m <- as.matrix(centroids$centers[, c('lng.std', 'lat.std')])
m.size <- nrow(centroids$centers)
X.time.m.diff.sq <- rcpp_diff_sq_mx(X.time.m, X.time.m, T)
X.time.m.diff.2norm <- rcpp_diff_2norm_mx(X.time.m, X.time.m, T)
X.geo.m.diff.sq <- rcpp_diff_sq_mx(X.geo.m, X.geo.m, T)
# create all data
batch.size <- 12e2
X.sample <- as.matrix(select(st_drop_geometry(crime.data.week.to.use), week, lng.std, lat.std))
y.sample <- c(as.matrix(select(st_drop_geometry(crime.data.week.to.use), count)))
sample.size <- length(y.sample)
n.batches <- ncol(matrix(seq(sample.size), nrow = batch.size))
print(paste0("Batches are ", n.batches))
# fit parameters
threshold <- 1e-4
step.size.var.par <- c(1e-3, 1e-2, 1e-2)
step.size.par <- c(1e-4, 1e-2, 1e-3)
learning.decay <- c(1, 1, .8)
# load data from scratch data - first run of code only
if (resuming.computation == "try-error") {
print("This is the first run of this code.")
load(file = '~/Dropbox (INSEAD)/Crime Modeling/Initialization study/fit.results_SET+SET+PERT.Rdata')
# load(file = '~/crime.modeling/data/fit.results_SET_SET_PERT.Rdata')
# hot start parameters
fit.results.clean <- list()
for(i in seq(length(fit.results))) {
if(!is.null(fit.results[[i]]))
fit.results.clean <- append(fit.results.clean,  fit.results[i])
}
evidence <- sapply(fit.results.clean, '[[', 1)
fit.order <- order(evidence, decreasing = T)
fit.pars <- lapply(fit.results.clean, '[[', 3)
hot.start.pars <- fit.pars[[((random.start.indicator - 1) %/% 5 + 1)]]
initial.par.svi <- c(hot.start.pars[1:2], rgamma(1, .5, .5),
hot.start.pars[3:6],
rgamma(3, .5, .5),
hot.start.pars[length(hot.start.pars)])
par.svi <- initial.par.svi
if(length(par.svi) != length(derivative.calls)) stop("Mismatch b/w n of derivatives and n of parameters")
par.svi.seq <- list()
print(c("Initial parameters are: ", round(initial.par.svi, 3)))
# initial conditions
epoch <- 0
iteration <- 0
save.count <- 1
batch.lik.sequence <- -Inf
m.svi <- rep(0, m.size)
S.svi <- Reduce('+', mclapply(covariance.calls[['K.mm']], eval))
}
# Run fit ---------------------------
repeat({
# check runtime
run.time <- difftime(Sys.time(), start.time, units = 'mins')
print(run.time)
# save every 5 hours
if (run.time > 300 * save.count) {
save(
initial.par.svi, par.svi, m.svi, S.svi, par.svi.seq,
epoch, iteration, batch.lik.sequence, positions.mx,
file = output.file.name,
safe = T
)
save.count <- save.count + 1
print(paste0('At ', round(run.time, 2), ', I have made save number ', save.count, '.'))
}
# update iteration
iteration <- iteration + 1
batch <- iteration %% n.batches
batch <- ifelse(batch == 0, n.batches, batch)
if (batch == 1) {
epoch <- epoch + 1
positions.mx <- matrix(sample(seq(sample.size)), nrow = batch.size)
print("Batches and positions updated.")
}
print(paste(c(epoch, iteration, batch, round(c(tail(batch.lik.sequence, 1), par.svi), 3)), collapse = " - "))
# draw minibatch
positions.batch.svi <- positions.mx[, batch]
y.svi <- y.sample[positions.batch.svi]
X.time.n <- as.matrix(X.sample[positions.batch.svi, 1])
X.geo.n <- as.matrix(X.sample[positions.batch.svi, 2:3])
# compute batch likelihood
batch.lik.sequence <- c(batch.lik.sequence, update.L3(covariance.calls, tail(par.svi, 1), jitter.v))
if (abs(diff(tail(batch.lik.sequence, 2))) < threshold) {
print("CONVEGENCE REACHED!!!")
break
}
# update variational parameters and hyperparameters
if (epoch < 3) {
var.par.svi <- update.variational.parameters(sigma.sq.svi = tail(par.svi, 1), step.size.var.par[1] * learning.decay[1] ^ (epoch - 1))
if (epoch == 2) {
par.svi <- par.svi + ADAM.step(derivative.calls, alpha = step.size.par[1] * learning.decay[1] ^ (epoch - 1))
}
}
if (epoch >= 3 && epoch < 10) {
var.par.svi <- update.variational.parameters(sigma.sq.svi = tail(par.svi, 1), step.size.var.par[2] * learning.decay[2] ^ (epoch - 1))
par.svi <- par.svi + ADAM.step(derivative.calls, alpha = step.size.par[2] * learning.decay[2] ^ (epoch - 1))
}
if (epoch >= 10) {
var.par.svi <- update.variational.parameters(sigma.sq.svi = tail(par.svi, 1), step.size.var.par[3] * learning.decay[3] ^ (epoch - 10))
par.svi <- par.svi + ADAM.step(derivative.calls, alpha = step.size.par[3] * learning.decay[3] ^ (epoch - 10))
}
# attribute new values to names
m.svi <- var.par.svi[[1]]
S.svi <- var.par.svi[[2]]
if((iteration %% 50) == 1) {
par.svi.seq[[(iteration - 1) %/% 50 + 1]] <- par.svi
}
})
# Save --------------------------------------------------------------------
save(
initial.par.svi, par.svi, m.svi, S.svi, par.svi.seq,
epoch, iteration, batch.lik.sequence, positions.mx,
file = output.file.name,
safe = T
)
rbind(par.svi)
print(paste(file.name, 'Done.', sep = ' - '))
print(difftime(Sys.time(), start.time, units = 'mins'))
par.svi <- par.svi + ADAM.step(derivative.calls, alpha = step.size.par[3] * learning.decay[3] ^ (epoch - 10))
